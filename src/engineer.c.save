/*~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-
 ~  Original Diku Mud copyright (C) 1990, 1991 by Sebastian Hammer,        ~
 ~  Michael Seifert, Hans Henrik St{rfeldt, Tom Madsen, and Katja Nyboe.   ~
 ~                                                                         ~
 ~  Merc Diku Mud improvments copyright (C) 1992, 1993 by Michael          ~
 ~  Chastain, Michael Quan, and Mitchell Tse.                              ~
 ~                                                                         ~
 ~  Ack 2.2 improvements copyright (C) 1994 by Stephen Dooley              ~
 ~  ACK!MUD is modified Merc2.0/2.1/2.2 code (c)Stephen Zepp 1998 Ver: 4.3 ~
 ~                                                                         ~
 ~  In order to use any part of this  PA  Diku Mud, you must comply with   ~
 ~  both the original Diku license in 'license.doc' as well the Merc       ~
 ~  license in 'license.txt', and the Ack!Mud license in 'ack_license.txt'.~
 ~  In particular, you may not remove any of these copyright notices.      ~
 ~                                                                         ~
 ~           _______      _____                                            ~
 ~          /  __  /\    / ___ \       222222        PA_MUD by Amnon Kruvi ~
 ~         /______/ /   / /___\ \            2       PA_MUD is modified    ~
 ~        / _______/   / _______ \           2       Ack!Mud, v4.3         ~
 ~       /_/          /_/       \_\        2                               ~
 ~                                      2                                  ~
 ~                                     2222222                             ~
 ~                                                                         ~
 ~                                                                         ~
 ~   Years of work have been invested to create DIKU, Merc, Ack and PA.    ~
 ~   Please show your respect by following the licenses, and issuing       ~
 ~   credits where due.                                                    ~
 ~                                                                         ~
 ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-*/

#if defined(macintosh)
#include <types.h>
#else
#include <sys/types.h>
#endif
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ack.h"
#include "tables.h"

/* This file should include all the engineering stuff */

#define LOG_NORMAL      0
#define LOG_ALWAYS      1
#define LOG_NEVER       2

DECLARE_DO_FUN( do_eng_exit	 	);
DECLARE_DO_FUN( do_eng_connect	 	);
DECLARE_DO_FUN( do_ecommands	 	);
const   struct  cmd_type       eng_cmd_table   [] =
{ 
    { "north",          do_north,       POS_ENGINEERING,    0,  LOG_NORMAL },
    { "east",           do_east,        POS_ENGINEERING,    0,  LOG_NORMAL },
    { "south",          do_south,       POS_ENGINEERING,    0,  LOG_NORMAL },
    { "west",           do_west,        POS_ENGINEERING,    0,  LOG_NORMAL },
    { "look",           do_look,        POS_ENGINEERING,    0,  LOG_NORMAL },
    { "score",          do_score,       POS_ENGINEERING,    0,  LOG_NORMAL },
    { "tell",           do_tell,        POS_ENGINEERING,    0,  LOG_NORMAL },

    { "help",		do_ecommands,	POS_ENGINEERING,    0,  LOG_NORMAL },
    { "commands",	do_ecommands,	POS_ENGINEERING,    0,  LOG_NORMAL },
    { "who",		do_who,		POS_ENGINEERING,    0,  LOG_NORMAL },
    { "exit",		do_eng_exit,	POS_ENGINEERING,    0,  LOG_NORMAL },
    { "stop",		do_stop,	POS_ENGINEERING,    0,  LOG_NORMAL },
    { "connect",	do_eng_connect,	POS_ENGINEERING,    0,  LOG_NORMAL },

    { "",               0,              POS_DEAD,        0,  LOG_NORMAL }
};

void engineering_interpret( CHAR_DATA *ch, char *argument )
{
    char command[MAX_INPUT_LENGTH];
    char logline[MAX_INPUT_LENGTH];
    int cmd;
    bool found;
    OBJ_DATA *obj;
      
    if ( !ch->in_vehicle )
    {
	ch->position = POS_STANDING;
	return;
    }
    if ( ( obj = get_eq_char(ch,WEAR_HOLD_HAND_L) ) == NULL || obj->item_type != ITEM_TOOLKIT )
    {
	send_to_char( "You have lost your toolkit!\n\r", ch );
	ch->position = POS_STANDING;
	return;
    }

    /*  
     * Strip leading spaces.
     */
    while ( isspace(*argument) )
        argument++;
    if ( argument[0] == '\0' )
        return;
     
    strcpy( logline, argument );
    if ( !isalpha(argument[0]) && !isdigit(argument[0]) ) 
    {
        command[0] = argument[0];
        command[1] = '\0';
        argument++;
        while ( isspace(*argument) )
            argument++;
    } 
    else
    {  
        argument = one_argument( argument, command );
    }
     
    
    /*
     * Look for command in command table.
     */
    found = FALSE;
    for ( cmd = 0; eng_cmd_table[cmd].name[0] != '\0'; cmd++ )
    {
        if ( command[0] == eng_cmd_table[cmd].name[0]
        &&   !str_prefix( command, eng_cmd_table[cmd].name )
        &&   get_trust(ch) >= eng_cmd_table[cmd].level )
        {
            found = TRUE;
            break;
        }
    }

   if ( IS_BUSY(ch) && str_cmp(eng_cmd_table[cmd].name,"stop") )
   {
        send_to_char( "Finish or 'stop' your other process, first.\n\r", ch );
        return;
   }
            
    /*
     * Log and snoop.
     */
    if ( eng_cmd_table[cmd].log == LOG_NEVER )
        strcpy( logline, "XXXXXXXX XXXXXXXX XXXXXXXX" );
     
    if ( ( IS_SET(ch->act, PLR_LOG) )
    ||   fLogAll
    ||  eng_cmd_table[cmd].log == LOG_ALWAYS )
    {
        sprintf( log_buf, "Log %s: %s", ch->name, logline );
        log_string( log_buf );
    }
    if ( ch->desc != NULL && ch->desc->snoop_by != NULL ) 
    {
        write_to_buffer( ch->desc->snoop_by, "% ",    2 );
        write_to_buffer( ch->desc->snoop_by, logline, 0 );
        write_to_buffer( ch->desc->snoop_by, "\n\r",  2 );
    }   
     
    if ( !found )
    {
	send_to_char( "Invalid command.\n\r", ch );
        return;
    }
    
    
    (*eng_cmd_table[cmd].do_fun) ( ch, argument );
        
    tail_chain( );
    return;
}

void do_eng_exit( CHAR_DATA *ch, char *argument )
{
	act( "You stop your work.", ch, NULL, NULL, TO_CHAR );
	ch->position = POS_STANDING;
	return;
}
void do_ecommands( CHAR_DATA *ch, char *argument )
{
   char buf[MAX_STRING_LENGTH];   
   char out[MAX_STRING_LENGTH];
   int cmd;
   int col = 0;
    
   sprintf( out, "Engineering Commands Available to You:\n\r" );
    
   for ( cmd = 0; eng_cmd_table[cmd].name[0] != '\0'; cmd++ )
   {
      if ( eng_cmd_table[cmd].level > get_trust( ch ) )
         continue; 
      sprintf( buf, "%-20s    ", eng_cmd_table[cmd].name );
      safe_strcat( MSL, out, buf );
      if ( ++col % 3 == 0 )
         safe_strcat( MSL, out, "\n\r" );
   }  
   safe_strcat( MSL, out, "\n\r" );
   send_to_char( out, ch );
   return;
}   

void do_eng_connect( CHAR_DATA *ch, char *argument )
{
	OBJ_DATA *obj;
	int wire1,wire2;
	char arg[MSL];
	char buf[MSL];

    	if ( ( obj = get_eq_char(ch,WEAR_HOLD_HAND_L) ) == NULL || obj->item_type != ITEM_TOOLKIT )
    	{
		send_to_char( "You have lost your toolkit!\n\r", ch );
		return;
    	}
	argument = one_argument(argument,arg);
	wire1 = 0;
	wire2 = 0;
	if ( !str_prefix(arg,"green") )
		wire1 = 0;
	else if ( !str_prefix(arg,"blue") )
		wire1 = 1;
	else if ( !str_prefix(arg,"red") )
		wire1 = 2;
	else if ( !str_prefix(arg,"yellow") )
		wire1 = 3;
	else
	{
		send_to_char( "Wire colors are: Green, Blue, Red, Yellow.\n\r", ch );
		return;
	}
	if ( !str_prefix(argument,"green") )
		wire1 = 4;
	else if ( !str_prefix(argument,"blue") )
		wire1 = 5;
	else if ( !str_prefix(argument,"red") )
		wire1 = 6;
	else if ( !str_prefix(argument,"yellow") )
		wire1 = 7;
	else
	{
		send_to_char( "Wire colors are: Green, Blue, Red, Yellow.\n\r", ch );
		return;
	}

	if ( obj->value[wire1] == 0 && obj->value[wire2] == 0 )
	{
		send_to_char( "Those wires have already been connected.\n\r", ch );
		return;
	}
	if ( obj->value[wire1] == obj->value[wire2] )
	{
		send_to_char( "Success! The wires connect.\n\r", ch );
		obj->value[wire1] = 0;
		obj->value[wire2] = 0;
	}
	else
	{
		ch->position = POS_STANDING;
		send_to_char( "The wires flickered, and you got ZAPPED!!\n\r", ch );
		damage(ch,ch,50,-1);
		return;
	}
	if ( obj->value[0] == 0 && obj->value[1] == 0 && obj->value[2] == 0 && obj->value[3] == 0 )
	{
		send_to_char( "Success!\n\r", ch );
		if ( ch->section == SECTION_ENGINE_ROOM )
		{
			ch->in_vehicle->speed++;
			sprintf(buf,"Your speed has been increased to %d!\n\r", ch->in_vehicle->speed);
			send_to_char(buf,ch);
		}
		else if ( ch->section == SECTION_CONTROL_ROOM )
		{
			ch->in_vehicle->range++;
			sprintf(buf,"Your combat range has been increased to %d!\n\r", ch->in_vehicle->range);
			send_to_char(buf,ch);
		}
	}
	return;
}

void do_engineer( CHAR_DATA *ch, char *argument )
{
	OBJ_DATA *obj;
	VEHICLE_DATA *vhc;
	int wire[5];
	int val = -1;
	if ( ( vhc = ch->in_vehicle ) == NULL )
	{
		send_to_char( "You must be inside a spaceship.\n\r", ch );
		return;
	}
    	if ( ( obj = get_eq_char(ch,WEAR_HOLD_HAND_L) ) == NULL || obj->item_type != ITEM_TOOLKIT )
    	{
		send_to_char( "You must be holding a toolkit in your left hand.\n\r", ch );
		return;
    	}
	if ( ch->section == SECTION_ENGINE_ROOM )
		val = vhc->speed;
	else if ( ch->section == SECTIoN_CONTROL_ROOM )
		val = ch->in_vehicle->range;

	if ( val == -1 )
	{
		send_to_char( "There is nothing you can upgrade here... yet...\n\r", ch );
		return;
	}
	if ( obj->level > ch->pcdata->skill[gsn_engineering] * 3 )
	{
		char buf[MSL];
		sprintf( buf, "At your proficiency level, you can only use level %d toolkits or worse.\n\r", ch->pcdata->skill[gsn_engineering]*3);
		send_to_char(buf,ch);
		return;
	}
	if ( obj->level < val )
	{
		send_to_char( "You must use a better toolkit for these parts.\n\r", ch );
		return;
	}
	obj->value[number_range(0,3)] = 1;
	obj->value[number_range(0,3)] = 1;
}
